??? from here until ???END lines may have been inserted/deleted
import libsbgnpy.libsbgn as libsbgn
from csbgnpy import *
# from EntityClazz import *
# from ProcessClazz import *
# from ModulationClazz import *
# from SubEntityClazz import *
# from StateVariable import *
# from LogicalOperator import *
# from UnitOfInformation import *

class Utils:
    @staticmethod
    def get_object_from_collection(obj, coll):
        for obj2 in coll:
            if obj2 == obj:
                return obj2
        return None

    @staticmethod
    def get_glyph_by_id_or_port_id(sbgnmap, i):
        for glyph in sbgnmap.get_glyph():
            if glyph.get_id() == i:
                return glyph
            for port in glyph.get_port():
                if port.get_id() == i:
                return glyph
        return None

    @staticmethod
        def get_glyph_by_id(sbgnmap, id):
            for glyph in sbgnmap.get_glyph():
                if glyph.get_id() == id:
                    return glyph
            return None


    @staticmethod
    def read_SBGNML(*filenames):
        net = csbgnpy.PD.Network()
        compartments = set()
        entities = set()
        processes = set()
        modulations = set()
        logical_operator_nodes = set()
        for filename in filenames:
???END
            sbgn = libsbgn.parse(filename, silence=True)
            sbgnmap = sbgn.get_map()
            for glyph in sbgnmap.get_glyph(): # making compartments
                if glyph.get_class().name == "COMPARTMENT":
                    comp = Utils._make_compartment_from_glyph(glyph)
                    compartments.add(comp)
            for glyph in sbgnmap.get_glyph(): # making entities
                if glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.EntityClazz)]:
                    entity = csbgnpy.PD.Utils._make_entity_from_glyph(glyph, sbgnmap, compartments)
                    entities.add(entity)
            for glyph in sbgnmap.get_glyph(): # making processes
                if glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.ProcessClazz)]:
                    proc = Utils._make_process_from_glyph(glyph, sbgnmap, entities, compartments)
                    processes.add(proc)
            for glyph in sbgnmap.get_glyph(): # making logical operator nodes
                if glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.AF.LogicalOperatorClazz)]:
                    op  = csbgnpy.PD.Utils._make_logical_operator_node_from_glyph(glyph, sbgnmap, entities, compartments, logical_operator_nodes)
                    logical_operator_nodes.add(op)
            for arc in sbgnmap.get_arc(): # making modulations
                if arc.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.ModulationClazz)]:
                    mod = csbgnpy.PD.Utils._make_modulation_from_arc(arc, sbgnmap, activities, compartments, processes, logical_operator_nodes)
                    modulations.add(mod)
        for entity in entities:
            net.add_entity(entity)
        for proc in processes:
            net.add_process(proc)
        for mod in modulations:
            net.add_modulation(mod)
        for comp in compartments:
            net.add_compartment(comp)
        for op in logical_operator_nodes:
            net.add_logical_operator_node(op)
        return net

    @staticmethod
    def _make_ui_from_glyph(glyph):
        if glyph.get_label() is not None:
            label = glyph.get_label().get_text()
            if ':' in label:
                return csbgnpy.PD.UnitOfInformation(glyph.get_id(), label.split(':')[0], label.split(':')[1])
            else:
                return csbgnpy.PD.UnitOfInformation(glyph.get_id(), None, label)
        else:
            return csbgnpy.PD.UnitOfInformation(glyph.get_id(), None, None)

    @staticmethod
    def _make_sv_from_glyph(glyph):
        if glyph.get_state() is not None:
            return csbgnpy.PD.StateVariable(glyph.get_id(), glyph.get_state().get_variable(), glyph.get_state().get_value())
        else:
            return csbgnpy.PD.StateVariable()

    @staticmethod
    def _make_compartment_from_glyph(glyph):
        comp = Compartment()
        comp.id = glyph.get_id()
        comp.label = glyph.get_label().get_text()
        return comp

    @staticmethod
    def _make_entity_from_glyph(glyph, sbgnmap, compartments):
        entity = Entity()
        entity.id = glyph.get_id()
        entity.clazz = csbgnpy.PD.EntityClazz[glyph.get_class().name]
        if glyph.get_label() is not None:
            entity.label = glyph.get_label().get_text()
        comp_id = glyph.get_compartmentRef()
        if comp_id is not None:
            comp_glyph = csbgnpy.PD.Utils.get_glyph_by_id(sbgnmap, comp_id)
            comp = csbgnpy.PD.Utils._make_compartment_from_glyph(comp_glyph)
            existent_comp = csbgnpy.PD.Utils.get_object_from_collection(comp, compartments)
            entity.compartment = existent_comp
        for subglyph in glyph.get_glyph():
            if subglyph.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.EntityClazz)]:
                subentity = csbgnpy.PD.Utils._make_entity_from_glyph(glyph, sbgnmap, compartments)
                entity.add_component(subentity)
            elif subglyph.get_class().name == "STATE_VARIABLE":
                sv = Utils._make_sv_from_glyph(subglyph)
                entity.add_state_variable(sv)
            elif subglyph.get_class().name == "UNIT_OF_INFORMATION":
                ui = Utils._make_ui_from_glyph(subglyph)
                entity.add_unit_of_information(ui)
        return entity

    @staticmethod
    def _make_logical_operator_node_from_glyph(glyph, sbgnmap, entities, compartments, logical_operator_nodes):
        op = csbgnpy.PD.LogicalOperatorNode()
        op.clazz = csbgnpy.PD.LogicalOperatorClazz[glyph.get_class().name]
        for arc in sbgnmap.get_arc():
            if arc.get_class().name == "LOGIC_ARC" and arc.get_target() in [port.get_id() for port in glyph.get_port()]:
                source_id = arc.get_source()
                source_glyph = csbgnpy.PD.Utils.get_glyph_by_id_or_port_id(sbgnmap, source_id)
                if source_glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.EntityClazz)]:
                    source = csbgnpy.PD.Utils._make_entity_from_glyph(source_glyph, sbgnmap, compartments)
                    existent_source = csbgnpy.PD.Utils.get_object_from_collection(source, entities)
                    op.add_child(existent_source)
                elif source_glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.PD.LogicalOperatorClazz)]:
                    source = csbgnpy.PD.Utils._make_logical_operator_node_from_glyph(source_glyph, sbgnmap, entities, compartments, logical_operator_nodes)
                    existent_source = csbgnpy.PD.Utils.get_object_from_collection(source, logical_operator_nodes)
                    if existent_source is not None:
                        op.add_child(existent_source)
                    else:
                        op.add_child(source)
            return op

    @staticmethod
    def _make_process_from_glyph(glyph, sbgnmap, entities, compartments):
        proc = csbgnpy.PD.Process()
        proc.id = glyph.get_id()
        proc.clazz = csbgnpy.PD.ProcessClazz[glyph.get_class().name]
        if glyph.get_label() is not None:
            proc.label = glyph.get_label().get_text()
        for arc in sbgnmap.get_arc():
            if arc.get_class().name == "CONSUMPTION" and csbgnpy.PD.Utils.get_glyph_by_id_or_port_id(sbgnmap, arc.get_target()) == glyph:
                source_id = arc.get_source()
                source_glyph = csbgnpy.PD.Utils.get_glyph_by_id_or_port_id(sbgnmap, source_glyph)
                source = csbgnpy.PD.Utils._make_entity_from_glyph(source, sbgnmap, compartments)
                existent_source = csbgnpy.PD.Utils.get_object_from_collection(source, entities)
                proc.add_reactant(existent_source)
            elif arc.get_class().name == "PRODUCTION" and csbgnpy.PD.Utils.get_glyph_by_id_or_port_id(sbgnmap, arc.get_source()) == glyph:
                target_id = arc.get_target()
                target_glyph = csbgnpy.PD.Utils.get_glyph_by_id_or_port_id(sbgnmap, target_glyph)
                target = csbgnpy.PD.Utils._make_entity_from_glyph(target, sbgnmap, compartments)
                existent_target = csbgnpy.PD.Utils.get_object_from_collection(target, entities)
                proc.add_product(existent_product)
            return proc
       return modulation

    @staticmethod
    def _make_modulation_from_arc(arc, sbgnmap, activities, compartments, logical_operator_nodes):
        source_id = arc.get_source()
        source_glyph = csbgnpy.AF.Utils.get_glyph_by_id_or_port_id(sbgnmap, source_id)
        if source_glyph.get_class().name in [attribute.name for attribute in list(csbgnpy.AF.ActivityClazz)]:
            source = csbgnpy.AF.Utils._make_activity_from_glyph(source_glyph, sbgnmap, compartments)
            existent_source = csbgnpy.AF.Utils.get_object_from_collection(sourceActivity, activities)
        elif source_glyph.get_class().name in [attribute.name for attribute in list(LogicalOperatorClazz)]:
            source = csbgnpy.AF.Utils._makeLogicalOperatorFromGlyph(source_glyph, sbgnmap, activities, compartments)
            existent_source = csbgnpy.AF.Utils.get_object_from_collection(source, logical_operator_odes)
        target_id = arc.get_target()
        target_glyph = csbgnpy.AF.Utils.get_glyph_by_id_or_port_id(sbgnmap, target_id)
        target = csbgnpy.AF.Utils._make_activity_from_glyph(target_glyph, sbgnmap, compartments)
        existent_target = csbgnpy.AF.Utils.get_object_from_collection(target, activities)
        clazz = csbgnpy.AF.ModulationClazz[arc.get_class().name]
        modulation = csbgnpy.AF.Modulation(clazz, existent_source, existent_target)
        return modulation

    @staticmethod
    def getCG2ASP(net):
        s = ""
        for entity in net.getEntities():
            if not net.isSink(entity):
                s += "epn({0}).\n".format(entity.getId())
                if entity.hasLabel() and entity.getLabel() != "":
                    s += "belong({0}, {1}).\n".format(Utils._normalizeLabel(entity.getLabel()), entity.getId())
                for subentity in entity.getComponents():
                    if subentity.hasLabel():
                        s += "belong({0}, {1}).\n".format(Utils._normalizeLabel(subentity.getLabel()), entity.getId())
        for process in net.getProcesses():
            reactants = process.getReactants()
            products = process.getProducts()
            if len(reactants) == 0:
                for product in products:
                    for product2 in products:
                        if product != product2:
                            if not net.isSink(product):
                                s += "edge({0},{1},{2}).\n".format(product.getId(), product2.getId(), process.getId())
            else:
                for reactant in reactants:
                    for product in products:
                        if not net.isSink(product):
                            s += "edge({0},{1},{2}).\n".format(reactant.getId(), product.getId(), process.getId())
        return s

    @staticmethod
    def writeCG2ASP(net, filename):
        ofile = open(filename, "w")
        s = Utils.getCG2ASP(net)
        ofile.write(s)
        ofile.close()

    @staticmethod
    def _normalizeLabel(label):
        label = label.replace("*","_")
        label = label.replace("+","_plus")
        label = label.replace("/","_")
        label = label.replace(" ","_")
        label = label.replace("-","_")
        label = label.lower()
        return label

    @staticmethod
    def writeSBGNML(net, filename):
        sbgn = Utils._makeSBGNML(net)
        sbgn.write_file(filename)
        ifile = open(filename)
        s = ifile.read()
        ifile.close()
        s = s.replace("sbgn:","")
        s = s.replace(' xmlns:sbgn="http://sbgn.org/libsbgn/0.2"', "")
        s = s.replace('."', '.0"')
        ofile = open(filename, "w")
        ofile.write(s)
        ofile.close()

    def _makeGlyphFromCompartment(compartment, iglyph):
        g = libsbgn.glyph()
        g.set_class(libsbgn.GlyphClass["COMPARTMENT"])
        g.set_id("glyph{0}".format(iglyph))
        iglyph += 1
        label = libsbgn.label()
        if compartment.getLabel() is not None:
            label.set_text(compartment.getLabel())
        else:
            label.set_text("")
        g.set_label(label)
        return iglyph, g


    @staticmethod
    def _makeGlyphFromEntity(epn, iglyph, dids):
        g = libsbgn.glyph()
        g.set_class(libsbgn.GlyphClass[epn.getClazz().name])
        g.set_id("glyph{0}".format(iglyph))
        iglyph += 1
        bbox = libsbgn.bbox(0, 0, epn.getClazz().value["w"], epn.getClazz().value["h"])
        g.set_bbox(bbox)
        label = libsbgn.label()
        if epn.getLabel() is not None:
            label.set_text(epn.getLabel())
        else:
            label.set_text("")
        g.set_label(label)
        if epn.getCompartmentRef() is not None:
            g.set_compartmentRef(dids[epn.getCompartmentRef()])
        for component in epn.getComponents():
            iglyph, gc = Utils._makeGlyphFromComponent(component, iglyph)
            g.add_glyph(gc)
        for i, sv in enumerate(epn.getStateVariables()):
            gsv = libsbgn.glyph()
            gsv.set_id("glyph{0}".format(iglyph))
            iglyph += 1
            gsv.set_class(libsbgn.GlyphClass["STATE_VARIABLE"])
            gsv.set_state(libsbgn.stateType(sv.getVariable(), sv.getValue()))
            bbox = libsbgn.bbox()
            bbox.set_x(g.get_bbox().get_x()+40*i+6)
            bbox.set_y(g.get_bbox().get_y()-10)
            bbox.set_h(22)
            bbox.set_w(40)
            gsv.set_bbox(bbox)
            g.add_glyph(gsv)
        for i, ui in enumerate(epn.getUnitsOfInformation()):
            gui = libsbgn.glyph()
            gui.set_id("glyph{0}".format(iglyph))
            iglyph += 1
            gui.set_class(libsbgn.GlyphClass["UNIT_OF_INFORMATION"])
            label = libsbgn.label()
            if ui.getPrefix() is not None:
                label.set_text(ui.getPrefix()+':'+ui.getLabel())
            else:
                label.set_text(ui.getLabel())
            gui.set_label(label)
            bbox = libsbgn.bbox()
            bbox.set_x(g.get_bbox().get_x()+40*i+6)
            bbox.set_y(g.get_bbox().get_y()-10)
            bbox.set_h(22)
            bbox.set_w(40)
            gui.set_bbox(bbox)
            g.add_glyph(gui)
        return iglyph, g

    @staticmethod
    def _makeGlyphFromLogicalOperator(lop, iglyph):
        g = libsbgn.glyph()
        g.set_class(libsbgn.GlyphClass[lop.getClazz().name])
        g.set_id("glyph{0}".format(iglyph))
        iglyph += 1
        bbox = libsbgn.bbox(0, 0, lop.getClazz().value["w"], lop.getClazz().value["h"])
        g.set_bbox(bbox)
        return iglyph, g

    @staticmethod
    def _makeGlyphsFromLogicalOperatorRec(lop, iglyph, dids):
        glyphs = set()
        iglyph, glyph = Utils._makeGlyphFromLogicalOperator(lop, iglyph)
        glyphs.add(glyph)
        dids[lop] = glyph.get_id()
        for child in lop.children:
            if child.getClazz().name in [attribute.name for attribute in list(LogicalOperatorClazz)]:
                iglyph, childGlyphs = Utils._makeGlyphsFromLogicalOperatorRec(child, iglyph, dids)
                glyphs = glyphs.union(childGlyphs)
        return iglyph, glyphs

    @staticmethod
    def _makeGlyphsFromLogicalFunction(lf, iglyph, dids):
        root = lf.getRoot()
        iglyph, glyphs = Utils._makeGlyphsFromLogicalOperatorRec(root, iglyph, dids)
        return iglyph, glyphs


    @staticmethod
    def _makeGlyphFromComponent(comp, iglyph):
        g = libsbgn.glyph()
        g.set_class(libsbgn.GlyphClass[comp.getClazz().name])
        g.set_id("glyph{0}".format(iglyph))
        iglyph += 1
        bbox = libsbgn.bbox(0, 0, comp.getClazz().value["w"], comp.getClazz().value["h"])
        g.set_bbox(bbox)
        label = libsbgn.label()
        label.set_text(comp.getLabel())
        g.set_label(label)
        for component in comp.getComponents():
            iglyph, gc = Utils._makeGlyphFromComponent(component, iglyph)
            g.add_glyph(gc)
        for i, sv in enumerate(comp.getStateVariables()):
            gsv = libsbgn.glyph()
            gsv.set_id("glyph{0}".format(iglyph))
            iglyph += 1
            gsv.set_class(libsbgn.GlyphClass["STATE_VARIABLE"])
            gsv.set_state(libsbgn.stateType(sv.getVariable(), sv.getValue()))
            bbox = libsbgn.bbox()
            bbox.set_x(g.get_bbox().get_x()+40*i+6)
            bbox.set_y(g.get_bbox().get_y()-10)
            bbox.set_h(22)
            bbox.set_w(40)
            gsv.set_bbox(bbox)
            g.add_glyph(gsv)
        return iglyph, g


    @staticmethod
    def _makeGlyphFromProcess(process, iglyph):
        p = libsbgn.glyph()
        p.set_class(libsbgn.GlyphClass[process.getClazz().name])
        p.set_id("glyph{0}".format(iglyph))
        iglyph += 1
        bbox = libsbgn.bbox(0, 0, process.getClazz().value["w"], process.getClazz().value["h"])
        p.set_bbox(bbox)
        port1 = libsbgn.port()
        # port1.set_id("{0}.1".format(p.get_id()))
        # port1.set_y(bbox.get_y() + bbox.get_h() / 2)
        # port1.set_x(bbox.get_x())
        # port2 = libsbgn.port()
        # port2.set_id("{0}.2".format(p.get_id()))
        # port2.set_y(bbox.get_y() + bbox.get_h() / 2)
        # port2.set_x(bbox.get_x() + bbox.get_w())
        # p.add_port(port1)
        # p.add_port(port2)
        return iglyph, p

    @staticmethod
    def _makeArcsFromProcess(process, iarc, dids):
        arcs = []
        for reactant in process.getReactants():
            arc = libsbgn.arc()
            start = libsbgn.startType(0, 0)
            end = libsbgn.endType(0, 0)
            arc.set_source(dids[reactant])
            # arc.set_target("{0}.1".format(process.getId()))
            arc.set_target(dids[process])
            arc.set_id("arc{0}".format(iarc))
            iarc += 1
            arc.set_start(start)
            arc.set_end(end)
            arc.set_class(libsbgn.ArcClass.CONSUMPTION)
            arcs.append(arc)
        for product in process.getProducts():
            arc = libsbgn.arc()
            start = libsbgn.startType(0, 0)
            end = libsbgn.endType(0, 0)
            # arc.set_source("{0}.2".format(process.getId()))
            arc.set_source(dids[process])
            arc.set_target(dids[product])
            arc.set_id("arc{0}".format(iarc))
            iarc += 1
            arc.set_start(start)
            arc.set_end(end)
            arc.set_class(libsbgn.ArcClass.PRODUCTION)
            arcs.append(arc)
        return iarc, arcs

    @staticmethod
    def _makeArcFromModulation(modulation, iarc, dids):
        arc = libsbgn.arc()
        start = libsbgn.startType(0, 0)
        end = libsbgn.endType(0, 0)
        if isinstance(modulation.getSource(), LogicalFunction):
            arc.set_source(dids[modulation.getSource().getRoot()])
        else:
            arc.set_source(dids[modulation.getSource()])
        arc.set_target(dids[modulation.getTarget()])
        arc.set_id("arc{0}".format(iarc))
        iarc += 1
        arc.set_start(start)
        arc.set_end(end)
        arc.set_class(libsbgn.ArcClass[modulation.getClazz().name])
        return iarc, arc

    @staticmethod
    def _makeArcsFromLogicalOperatorRec(lop, iarc, dids):
        arcs = set()
        for child in lop.getChildren():
            arc = libsbgn.arc()
            start = libsbgn.startType(0, 0)
            end = libsbgn.endType(0, 0)
            arc.set_source(dids[child])
            arc.set_target(dids[lop])
            arc.set_id("arc{0}".format(iarc))
            iarc += 1
            arc.set_start(start)
            arc.set_end(end)
            arc.set_class(libsbgn.ArcClass["LOGIC_ARC"])
            arcs.add(arc)
            if child.getClazz().name in [attribute.name for attribute in list(LogicalOperatorClazz)]:
                iarc, childArcs = Utils._makeArcsFromLogicalOperatorRec(child, iarc, dids)
                arcs = arcs.union(childArcs)
        return iarc, arcs

    @staticmethod
    def _makeArcsFromLogicalFunction(lf, iarc, dids):
        root = lf.getRoot()
        iarc, arcs = Utils._makeArcsFromLogicalOperatorRec(root, iarc, dids)
        return iarc, arcs

    @staticmethod
    def _makeSBGNML(net):
        iglyph = 0
        iarc = 0
        sbgn = libsbgn.sbgn()
        sbgnmap = libsbgn.map()
        language = libsbgn.Language.PD
        sbgnmap.set_language(language)
        sbgn.set_map(sbgnmap);
        dids = {}
        for compartment in net.getCompartments():
            iglyph, g = Utils._makeGlyphFromCompartment(compartment, iglyph)
            sbgnmap.add_glyph(g)
            dids[compartment] = g.get_id()
        for epn in net.getEntities():
            iglyph, g = Utils._makeGlyphFromEntity(epn, iglyph, dids)
            sbgnmap.add_glyph(g)
            dids[epn] = g.get_id()
        for lf in net.getLogicalFunctions():
            iglyph, glyphs = Utils._makeGlyphsFromLogicalFunction(lf, iglyph, dids)
            for g in glyphs:
                sbgnmap.add_glyph(g)
            iarc, arcs = Utils._makeArcsFromLogicalFunction(lf, iarc, dids)
            for arc in arcs:
                sbgnmap.add_arc(arc)
        for process in net.getProcesses():
            iglyph, p = Utils._makeGlyphFromProcess(process, iglyph)
            sbgnmap.add_glyph(p)
            dids[process] = p.get_id()
            iarc, arcs = Utils._makeArcsFromProcess(process, iarc, dids)
            for arc in arcs:
                sbgnmap.add_arc(arc)
        for modulation in net.getModulations():
            iarc, arc = Utils._makeArcFromModulation(modulation, iarc, dids)
            sbgnmap.add_arc(arc)
        return sbgn

    @staticmethod
    def diff(net1, net2):
        for epn in net1.getEntities().difference(net2.getEntities()):
            print(epn)

if __name__ == "__main__":
    # net = Utils.readSBGNML("essailop.sbgn")
    net1 = Utils.readSBGNML("/home/rougny/ClockCycle/maps/merged.sbgn")
    net2 = Utils.readSBGNML("/home/rougny/ClockCycle/maps/merged_manual.sbgn")
    Utils.diff(net1, net2)
